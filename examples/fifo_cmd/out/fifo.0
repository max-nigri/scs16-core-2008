zero pass, spliting the input file into three arrays, @codes @codes_for_presentation @comments
    0 // /////////////////////////////////////////////////////////////////////
    1 // File:  		fifo.scs
    2 // Location:		
    3 // Created by:		Nadav Feldman                         
    4 // Date Creation:  	28.11.03
    5 // Version:		1.0                                                 
    6 // Modified:		
    7 // 
    8 // Project: 		SCS16
    9 // 
   10 // Purpose:		This progrem is made to check a fifo of 16 cells.
   11 // useing 2 loop one to fill the fifo and one to empty it.
   12 // 
   13 // Description:         
   14 // 
   15 // How to use it:	                                                 
   16 // 
   17 // ToDo:                                                           
   18 // 
   19 // /////////////////////////////////////////////////////////////////////
   20 // 
   21 nop                                                 // 
   22 // 
   23 // 
   24 `define BFA 0                                       // `define BFA 0
   25 `define FWP 8                                       // `define FWP 8
   26 `define FRP 9                                       // `define FRP 9
   27 `define FMN 10                                      // `define FMN 10
   28 // 
   29 // in this example we define a fifo of 16 lines located in RAM
   30 // in the region `BFA (Base Fifo Address) to `BFA+15
   31 // its control struct is located above the fifo region, however
   32 // its location is totally controlled by the programmer.
   33 // the control struct consist of 3 lines
   34 // RAM[16] is the rd pointer 
   35 // RAM[17] is the wr pointer
   36 // RAM[18] {full=0 empty=1 size[6:0]=16  len[6:0]=0}
   37 // 
   38 // 
   39 // fifo control structure initiation
   40 // in this specific example, I'm setting the rd,wr ptr to point to 9
   41 // which is near the middle of the fifo. this will demonstrate the
   42 // wrap around mechanism
   43 R6=16                                               // 
   44 RAM[R6++]=9                                         // RAM[16] is the rd pointer
   45 RAM[R6++]=9                                         // RAM[17] is the wr pointer
   46 RAM[R6++]=16'b0100011110000000                      // full=0 empty=1 size=16  len=0
   47 // 
   48 R5=20                                               // 
   49 // 
   50 // writing R5 times to an empty fifo
   51 // 
   52 loop L_fill_fifo_start L_fill_fifo_end R5           // fifo fill loop invokation
   53 // loop pre-conditioning
   54      R6=17                                          // 
   55      R1=RAM[R6++]                                   // loading the wr pointer to R1
   56      R0=RAM[R6++]                                   // loading the control to R0
   57 // 
   58 L_fill_fifo_start,  if (R0[15]){                    // checking the full
   59          nop                                        // full!!, do something			
   60           }                                         // 
   61           else{                                     // 
   62         R7=R1+`BFA                                  // calc abs wr ptr
   63         RAM[R7]=R4                                  // wr the data
   64         R4=R4+1                                     // inc the data
   65 L_fill_fifo_end,    (R0,R1)=fifo_wr(R0,R1)          // update control	
   66       }                                             // 
   67 // 
   68 RAM[17]=R1                                          // saving back the wr pointer to RAM[17]
   69 RAM[18]=R0                                          // saving back the control record to RAM[18]
   70 // 
   71 // 
   72       R1=RAM[16]                                    // loading the rd pointer to R1 
   73 // 
   74 // reading R5 times from a full fifo
   75 // 
   76 loop L_emp_fifo_start L_emp_fifo_end R5             // 
   77 L_emp_fifo_start,       if (R0[14]){                // checking the empty
   78          nop                                        // empty!!, do something
   79       }                                             // 
   80       else{                                         // 
   81         R7=R1+`BFA                                  // calc the abs rd ptr
   82         R4=RAM[R7]                                  // rd the data		
   83 L_emp_fifo_end,      (R0,R1)=fifo_rd(R0,R1)         // update control
   84       }                                             // 
   85 // 
   86 RAM[16]=R1                                          // saving back the rd pointer to RAM[16]
   87 RAM[18]=R0                                          // saving back the control record to RAM[18]
   88 // 
   89 wait c14                                            // stop
   90 nop                                                 // 
   91 // 
   92 // 
   93 // 
   94 // /////////////////////
